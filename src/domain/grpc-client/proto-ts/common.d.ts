// @generated by protobuf-ts 2.9.4 with parameter output_javascript_es2020
// @generated from protobuf file "common.proto" (syntax proto3)
// tslint:disable
//
//
// common.proto
//
// Contains RPC messages common to all services.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 *
 * Generic key/value attribute, used as metadata to describe other objects.
 *
 * @generated from protobuf message Attribute
 */
export interface Attribute {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 *
 * Metadata associated with ingested data.
 *
 * @generated from protobuf message EventMetadata
 */
export interface EventMetadata {
    /**
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * @generated from protobuf field: Timestamp startTimestamp = 2;
     */
    startTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: Timestamp stopTimestamp = 3;
     */
    stopTimestamp?: Timestamp;
}
/**
 *
 * Time instant containing fields for seconds since epoch and nanoseconds offset.
 *
 * @generated from protobuf message Timestamp
 */
export interface Timestamp {
    /**
     * @generated from protobuf field: uint64 epochSeconds = 1;
     */
    epochSeconds: bigint;
    /**
     * @generated from protobuf field: uint64 nanoseconds = 2;
     */
    nanoseconds: bigint;
}
/**
 *
 * Ordered list of Timestamp messages.
 *
 * @generated from protobuf message TimestampList
 */
export interface TimestampList {
    /**
     * @generated from protobuf field: repeated Timestamp timestamps = 1;
     */
    timestamps: Timestamp[];
}
/**
 *
 * Collection of timestamps identified by sampling interval.
 *
 * Uniform sampling is assumed within sampling interval.
 * Thus, the ordered collection of timestamps are defined as a contiguous, equally-spaced point set
 * {t1, t2, ..., tN} within the following interval:
 *
 *    [startTime, (count-1)*periodNanos]
 *
 * The timestamps {t1, t2, ..., tN} are then given by
 *
 *    t1 = startTime,
 *    t2 = startTime + 1 * periodNanos,
 *    t3 = startTime + 2 * periodNanos,
 *    ...
 *    tN = startTime + (N-1) * periodNanos,
 *
 * where N = count.
 *
 * @generated from protobuf message SamplingClock
 */
export interface SamplingClock {
    /**
     * @generated from protobuf field: Timestamp startTime = 1;
     */
    startTime?: Timestamp;
    /**
     * @generated from protobuf field: uint64 periodNanos = 2;
     */
    periodNanos: bigint;
    /**
     * @generated from protobuf field: uint32 count = 3;
     */
    count: number;
}
/**
 *
 * Specifies the set of timestamps for ingested data, either using an explicit list of timestamps, or a
 * Sampling Clock specifying interval start time, sampling period, and sample count.
 *
 * @generated from protobuf message DataTimestamps
 */
export interface DataTimestamps {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "samplingClock";
        /**
         * @generated from protobuf field: SamplingClock samplingClock = 1;
         */
        samplingClock: SamplingClock;
    } | {
        oneofKind: "timestampList";
        /**
         * @generated from protobuf field: TimestampList timestampList = 2;
         */
        timestampList: TimestampList;
    } | {
        oneofKind: undefined;
    };
}
/**
 *
 * Exceptional Method Result.
 *
 * Used to describe an exceptional result from a service method, such as a rejection or error handling request.
 * This message is used by all service RPC methods to indicate a problem executing the method.
 *
 * @generated from protobuf message ExceptionalResult
 */
export interface ExceptionalResult {
    /**
     * @generated from protobuf field: ExceptionalResult.ExceptionalResultStatus exceptionalResultStatus = 1;
     */
    exceptionalResultStatus: ExceptionalResult_ExceptionalResultStatus;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * @generated from protobuf enum ExceptionalResult.ExceptionalResultStatus
 */
export declare enum ExceptionalResult_ExceptionalResultStatus {
    /**
     * Indicates request was rejected during validation.
     *
     * @generated from protobuf enum value: RESULT_STATUS_REJECT = 0;
     */
    RESULT_STATUS_REJECT = 0,
    /**
     * Indicates an error was encountered in handling the request.
     *
     * @generated from protobuf enum value: RESULT_STATUS_ERROR = 1;
     */
    RESULT_STATUS_ERROR = 1,
    /**
     * Indicates the query returned no data.
     *
     * @generated from protobuf enum value: RESULT_STATUS_EMPTY = 2;
     */
    RESULT_STATUS_EMPTY = 2,
    /**
     * Indicates an invalid bidirectional stream query cursor operation request.
     *
     * @generated from protobuf enum value: RESULT_STATUS_NOT_READY = 3;
     */
    RESULT_STATUS_NOT_READY = 3
}
/**
 *
 * Data Column
 *
 * Contains a named vector of heterogeneous data values sampled for a particular PV.
 *
 *
 * @generated from protobuf message DataColumn
 */
export interface DataColumn {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated DataValue dataValues = 2;
     */
    dataValues: DataValue[];
}
/**
 *
 * Unit of Heterogeneous Data
 *
 * The message includes both a data field 'value' and a status field 'valueStatus'.
 * The 'value' field is the actual data value while the 'valueStatus' field represents the
 * condition of the value (i.e., typically at acquisition time).  Future versions may include
 * the status of the value within the archive (e.g., corrupt, truncated, etc.).
 *
 * The field 'value' is a union of all possible data types currently supported.  It represents one
 * unit of heterogeneous data.  Only one data type may be included in the message.
 *
 * The 'valueStatus' field is structure defined as an enclosed RPC message.  It contains information about the
 * value during acquisition, such as value alarm conditions, acquisition conditions, and any associated
 * message.  This field is subject to future modification for expanded use cases.
 *
 * @generated from protobuf message DataValue
 */
export interface DataValue {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "stringValue";
        /**
         * @generated from protobuf field: string stringValue = 1;
         */
        stringValue: string;
    } | {
        oneofKind: "booleanValue";
        /**
         * @generated from protobuf field: bool booleanValue = 2;
         */
        booleanValue: boolean;
    } | {
        oneofKind: "uintValue";
        /**
         * @generated from protobuf field: uint32 uintValue = 3;
         */
        uintValue: number;
    } | {
        oneofKind: "ulongValue";
        /**
         * @generated from protobuf field: uint64 ulongValue = 4;
         */
        ulongValue: bigint;
    } | {
        oneofKind: "intValue";
        /**
         * @generated from protobuf field: sint32 intValue = 5;
         */
        intValue: number;
    } | {
        oneofKind: "longValue";
        /**
         * @generated from protobuf field: sint64 longValue = 6;
         */
        longValue: bigint;
    } | {
        oneofKind: "floatValue";
        /**
         * @generated from protobuf field: float floatValue = 7;
         */
        floatValue: number;
    } | {
        oneofKind: "doubleValue";
        /**
         * @generated from protobuf field: double doubleValue = 8;
         */
        doubleValue: number;
    } | {
        oneofKind: "byteArrayValue";
        /**
         * @generated from protobuf field: bytes byteArrayValue = 9;
         */
        byteArrayValue: Uint8Array;
    } | {
        oneofKind: "arrayValue";
        /**
         * @generated from protobuf field: Array arrayValue = 10;
         */
        arrayValue: Array$;
    } | {
        oneofKind: "structureValue";
        /**
         * @generated from protobuf field: Structure structureValue = 11;
         */
        structureValue: Structure;
    } | {
        oneofKind: "imageValue";
        /**
         * @generated from protobuf field: Image imageValue = 12;
         */
        imageValue: Image;
    } | {
        oneofKind: "timestampValue";
        /**
         * @generated from protobuf field: Timestamp timestampValue = 13;
         */
        timestampValue: Timestamp;
    } | {
        oneofKind: undefined;
    };
    /**
     *
     * Status of Value
     *
     * Represents the condition of the value or associated hardware and software at
     * acquisition time.
     *
     * @generated from protobuf field: DataValue.ValueStatus valueStatus = 15;
     */
    valueStatus?: DataValue_ValueStatus;
}
/**
 *
 * Status of data value.
 *
 * The status definition reflects the value at acquisition time
 * (e.g., as in the EPIC record fields).
 *
 * @generated from protobuf message DataValue.ValueStatus
 */
export interface DataValue_ValueStatus {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: DataValue.ValueStatus.StatusCode statusCode = 2;
     */
    statusCode: DataValue_ValueStatus_StatusCode;
    /**
     * @generated from protobuf field: DataValue.ValueStatus.Severity severity = 3;
     */
    severity: DataValue_ValueStatus_Severity;
}
/**
 *
 * Source of an Exceptional Status
 *
 * @generated from protobuf enum DataValue.ValueStatus.StatusCode
 */
export declare enum DataValue_ValueStatus_StatusCode {
    /**
     * no status condition
     *
     * @generated from protobuf enum value: NO_STATUS = 0;
     */
    NO_STATUS = 0,
    /**
     * hardware device condition
     *
     * @generated from protobuf enum value: DEVICE_STATUS = 1;
     */
    DEVICE_STATUS = 1,
    /**
     * hardware driver condition
     *
     * @generated from protobuf enum value: DRIVER_STATUS = 2;
     */
    DRIVER_STATUS = 2,
    /**
     * device database record condition
     *
     * @generated from protobuf enum value: RECORD_STATUS = 3;
     */
    RECORD_STATUS = 3,
    /**
     * device database condition
     *
     * @generated from protobuf enum value: DB_STATUS = 4;
     */
    DB_STATUS = 4,
    /**
     * configuration condition
     *
     * @generated from protobuf enum value: CONF_STATUS = 5;
     */
    CONF_STATUS = 5,
    /**
     * unknown or undefined status condition
     *
     * @generated from protobuf enum value: UNDEFINED_STATUS = 6;
     */
    UNDEFINED_STATUS = 6,
    /**
     * data provider client condition
     *
     * @generated from protobuf enum value: CLIENT_STATUS = 7;
     */
    CLIENT_STATUS = 7
}
/**
 *
 * Value Alarm
 *
 * Pre-configured alarm conditions triggered by current data value.
 *
 * @generated from protobuf enum DataValue.ValueStatus.Severity
 */
export declare enum DataValue_ValueStatus_Severity {
    /**
     * no alarm conditions
     *
     * @generated from protobuf enum value: NO_ALARM = 0;
     */
    NO_ALARM = 0,
    /**
     * value has triggered a minor alarm condition
     *
     * @generated from protobuf enum value: MINOR_ALARM = 1;
     */
    MINOR_ALARM = 1,
    /**
     * value has triggered a major alarm condition
     *
     * @generated from protobuf enum value: MAJOR_ALARM = 2;
     */
    MAJOR_ALARM = 2,
    /**
     * value has triggered an invalid alarm condition
     *
     * @generated from protobuf enum value: INVALID_ALARM = 3;
     */
    INVALID_ALARM = 3,
    /**
     * unknown or undefined alarm condition present
     *
     * @generated from protobuf enum value: UNDEFINED_ALARM = 4;
     */
    UNDEFINED_ALARM = 4
}
/**
 *
 * Structure Data Value.
 *
 * Represents a unit of data whose value is a structure.
 *
 * Each level of a data structure may have an indefinite number of fields consisting
 * of (name, value) pairs.
 *
 * Note that the Structure message supports nested structure, and thus, complex data structures
 * can be represented.  The 'value' field within a (name, value) pair may contain another Structure
 * message supporting multi-level structuring.  The depth of the structuring is currently indefinite
 * but may have practical restrictions within service implementation (yet unreported).
 *
 * @generated from protobuf message Structure
 */
export interface Structure {
    /**
     * @generated from protobuf field: repeated Structure.Field fields = 1;
     */
    fields: Structure_Field[];
}
/**
 * @generated from protobuf message Structure.Field
 */
export interface Structure_Field {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: DataValue value = 2;
     */
    value?: DataValue;
}
/**
 *
 * Array Data Value.
 *
 * Represents a unit of data whose value is an array.
 *
 * Used for vectors whose values are arrays instead of individual scalar values.  Data values are any of the defined
 * DataValue types including simple scalars as well as more complex types like structures, images, and other nested
 * arrays.  The depth of array nesting is currently indefinite but may have practical restrictions within service
 * implementation (yet unreported).
 *
 * @generated from protobuf message Array
 */
export interface Array$ {
    /**
     * @generated from protobuf field: repeated DataValue dataValues = 1;
     */
    dataValues: DataValue[];
}
/**
 *
 * Image Data Value.
 *
 * Represents a unit of data whose value is an image file.
 *
 * Images are stored as raw data as a byte vector.  Interpretation is determined by standard
 * image file formats enumerated by FileType.
 *
 * @generated from protobuf message Image
 */
export interface Image {
    /**
     * @generated from protobuf field: bytes image = 1;
     */
    image: Uint8Array;
    /**
     * @generated from protobuf field: Image.FileType fileType = 2;
     */
    fileType: Image_FileType;
}
/**
 *
 * Image file format.  Also used as file extension.
 *
 * @generated from protobuf enum Image.FileType
 */
export declare enum Image_FileType {
    /**
     * @generated from protobuf enum value: RAW = 0;
     */
    RAW = 0,
    /**
     * @generated from protobuf enum value: JPEG = 1;
     */
    JPEG = 1,
    /**
     * @generated from protobuf enum value: GIF = 2;
     */
    GIF = 2,
    /**
     * @generated from protobuf enum value: TIFF = 3;
     */
    TIFF = 3,
    /**
     * @generated from protobuf enum value: BMP = 4;
     */
    BMP = 4,
    /**
     * @generated from protobuf enum value: PNG = 5;
     */
    PNG = 5,
    /**
     * @generated from protobuf enum value: EPS = 6;
     */
    EPS = 6,
    /**
     * @generated from protobuf enum value: SVG = 7;
     */
    SVG = 7,
    /**
     * @generated from protobuf enum value: PDF = 8;
     */
    PDF = 8
}
declare class Attribute$Type extends MessageType<Attribute> {
    constructor();
    create(value?: PartialMessage<Attribute>): Attribute;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Attribute): Attribute;
    internalBinaryWrite(message: Attribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message Attribute
 */
export declare const Attribute: Attribute$Type;
declare class EventMetadata$Type extends MessageType<EventMetadata> {
    constructor();
    create(value?: PartialMessage<EventMetadata>): EventMetadata;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventMetadata): EventMetadata;
    internalBinaryWrite(message: EventMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message EventMetadata
 */
export declare const EventMetadata: EventMetadata$Type;
declare class Timestamp$Type extends MessageType<Timestamp> {
    constructor();
    create(value?: PartialMessage<Timestamp>): Timestamp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Timestamp): Timestamp;
    internalBinaryWrite(message: Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message Timestamp
 */
export declare const Timestamp: Timestamp$Type;
declare class TimestampList$Type extends MessageType<TimestampList> {
    constructor();
    create(value?: PartialMessage<TimestampList>): TimestampList;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimestampList): TimestampList;
    internalBinaryWrite(message: TimestampList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message TimestampList
 */
export declare const TimestampList: TimestampList$Type;
declare class SamplingClock$Type extends MessageType<SamplingClock> {
    constructor();
    create(value?: PartialMessage<SamplingClock>): SamplingClock;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SamplingClock): SamplingClock;
    internalBinaryWrite(message: SamplingClock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message SamplingClock
 */
export declare const SamplingClock: SamplingClock$Type;
declare class DataTimestamps$Type extends MessageType<DataTimestamps> {
    constructor();
    create(value?: PartialMessage<DataTimestamps>): DataTimestamps;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataTimestamps): DataTimestamps;
    internalBinaryWrite(message: DataTimestamps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message DataTimestamps
 */
export declare const DataTimestamps: DataTimestamps$Type;
declare class ExceptionalResult$Type extends MessageType<ExceptionalResult> {
    constructor();
    create(value?: PartialMessage<ExceptionalResult>): ExceptionalResult;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExceptionalResult): ExceptionalResult;
    internalBinaryWrite(message: ExceptionalResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ExceptionalResult
 */
export declare const ExceptionalResult: ExceptionalResult$Type;
declare class DataColumn$Type extends MessageType<DataColumn> {
    constructor();
    create(value?: PartialMessage<DataColumn>): DataColumn;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataColumn): DataColumn;
    internalBinaryWrite(message: DataColumn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message DataColumn
 */
export declare const DataColumn: DataColumn$Type;
declare class DataValue$Type extends MessageType<DataValue> {
    constructor();
    create(value?: PartialMessage<DataValue>): DataValue;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataValue): DataValue;
    internalBinaryWrite(message: DataValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message DataValue
 */
export declare const DataValue: DataValue$Type;
declare class DataValue_ValueStatus$Type extends MessageType<DataValue_ValueStatus> {
    constructor();
    create(value?: PartialMessage<DataValue_ValueStatus>): DataValue_ValueStatus;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataValue_ValueStatus): DataValue_ValueStatus;
    internalBinaryWrite(message: DataValue_ValueStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message DataValue.ValueStatus
 */
export declare const DataValue_ValueStatus: DataValue_ValueStatus$Type;
declare class Structure$Type extends MessageType<Structure> {
    constructor();
    create(value?: PartialMessage<Structure>): Structure;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Structure): Structure;
    internalBinaryWrite(message: Structure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message Structure
 */
export declare const Structure: Structure$Type;
declare class Structure_Field$Type extends MessageType<Structure_Field> {
    constructor();
    create(value?: PartialMessage<Structure_Field>): Structure_Field;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Structure_Field): Structure_Field;
    internalBinaryWrite(message: Structure_Field, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message Structure.Field
 */
export declare const Structure_Field: Structure_Field$Type;
declare class Array$$Type extends MessageType<Array$> {
    constructor();
    create(value?: PartialMessage<Array$>): Array$;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Array$): Array$;
    internalBinaryWrite(message: Array$, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message Array
 */
export declare const Array$: Array$$Type;
declare class Image$Type extends MessageType<Image> {
    constructor();
    create(value?: PartialMessage<Image>): Image;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Image): Image;
    internalBinaryWrite(message: Image, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message Image
 */
export declare const Image: Image$Type;
export {};
