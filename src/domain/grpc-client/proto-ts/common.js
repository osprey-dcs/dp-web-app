// @generated by protobuf-ts 2.9.4 with parameter output_javascript_es2020
// @generated from protobuf file "common.proto" (syntax proto3)
// tslint:disable
//
//
// common.proto
//
// Contains RPC messages common to all services.
//
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf enum ExceptionalResult.ExceptionalResultStatus
 */
export var ExceptionalResult_ExceptionalResultStatus;
(function (ExceptionalResult_ExceptionalResultStatus) {
    /**
     * Indicates request was rejected during validation.
     *
     * @generated from protobuf enum value: RESULT_STATUS_REJECT = 0;
     */
    ExceptionalResult_ExceptionalResultStatus[ExceptionalResult_ExceptionalResultStatus["RESULT_STATUS_REJECT"] = 0] = "RESULT_STATUS_REJECT";
    /**
     * Indicates an error was encountered in handling the request.
     *
     * @generated from protobuf enum value: RESULT_STATUS_ERROR = 1;
     */
    ExceptionalResult_ExceptionalResultStatus[ExceptionalResult_ExceptionalResultStatus["RESULT_STATUS_ERROR"] = 1] = "RESULT_STATUS_ERROR";
    /**
     * Indicates the query returned no data.
     *
     * @generated from protobuf enum value: RESULT_STATUS_EMPTY = 2;
     */
    ExceptionalResult_ExceptionalResultStatus[ExceptionalResult_ExceptionalResultStatus["RESULT_STATUS_EMPTY"] = 2] = "RESULT_STATUS_EMPTY";
    /**
     * Indicates an invalid bidirectional stream query cursor operation request.
     *
     * @generated from protobuf enum value: RESULT_STATUS_NOT_READY = 3;
     */
    ExceptionalResult_ExceptionalResultStatus[ExceptionalResult_ExceptionalResultStatus["RESULT_STATUS_NOT_READY"] = 3] = "RESULT_STATUS_NOT_READY";
})(ExceptionalResult_ExceptionalResultStatus || (ExceptionalResult_ExceptionalResultStatus = {}));
/**
 *
 * Source of an Exceptional Status
 *
 * @generated from protobuf enum DataValue.ValueStatus.StatusCode
 */
export var DataValue_ValueStatus_StatusCode;
(function (DataValue_ValueStatus_StatusCode) {
    /**
     * no status condition
     *
     * @generated from protobuf enum value: NO_STATUS = 0;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["NO_STATUS"] = 0] = "NO_STATUS";
    /**
     * hardware device condition
     *
     * @generated from protobuf enum value: DEVICE_STATUS = 1;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["DEVICE_STATUS"] = 1] = "DEVICE_STATUS";
    /**
     * hardware driver condition
     *
     * @generated from protobuf enum value: DRIVER_STATUS = 2;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["DRIVER_STATUS"] = 2] = "DRIVER_STATUS";
    /**
     * device database record condition
     *
     * @generated from protobuf enum value: RECORD_STATUS = 3;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["RECORD_STATUS"] = 3] = "RECORD_STATUS";
    /**
     * device database condition
     *
     * @generated from protobuf enum value: DB_STATUS = 4;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["DB_STATUS"] = 4] = "DB_STATUS";
    /**
     * configuration condition
     *
     * @generated from protobuf enum value: CONF_STATUS = 5;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["CONF_STATUS"] = 5] = "CONF_STATUS";
    /**
     * unknown or undefined status condition
     *
     * @generated from protobuf enum value: UNDEFINED_STATUS = 6;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["UNDEFINED_STATUS"] = 6] = "UNDEFINED_STATUS";
    /**
     * data provider client condition
     *
     * @generated from protobuf enum value: CLIENT_STATUS = 7;
     */
    DataValue_ValueStatus_StatusCode[DataValue_ValueStatus_StatusCode["CLIENT_STATUS"] = 7] = "CLIENT_STATUS";
})(DataValue_ValueStatus_StatusCode || (DataValue_ValueStatus_StatusCode = {}));
/**
 *
 * Value Alarm
 *
 * Pre-configured alarm conditions triggered by current data value.
 *
 * @generated from protobuf enum DataValue.ValueStatus.Severity
 */
export var DataValue_ValueStatus_Severity;
(function (DataValue_ValueStatus_Severity) {
    /**
     * no alarm conditions
     *
     * @generated from protobuf enum value: NO_ALARM = 0;
     */
    DataValue_ValueStatus_Severity[DataValue_ValueStatus_Severity["NO_ALARM"] = 0] = "NO_ALARM";
    /**
     * value has triggered a minor alarm condition
     *
     * @generated from protobuf enum value: MINOR_ALARM = 1;
     */
    DataValue_ValueStatus_Severity[DataValue_ValueStatus_Severity["MINOR_ALARM"] = 1] = "MINOR_ALARM";
    /**
     * value has triggered a major alarm condition
     *
     * @generated from protobuf enum value: MAJOR_ALARM = 2;
     */
    DataValue_ValueStatus_Severity[DataValue_ValueStatus_Severity["MAJOR_ALARM"] = 2] = "MAJOR_ALARM";
    /**
     * value has triggered an invalid alarm condition
     *
     * @generated from protobuf enum value: INVALID_ALARM = 3;
     */
    DataValue_ValueStatus_Severity[DataValue_ValueStatus_Severity["INVALID_ALARM"] = 3] = "INVALID_ALARM";
    /**
     * unknown or undefined alarm condition present
     *
     * @generated from protobuf enum value: UNDEFINED_ALARM = 4;
     */
    DataValue_ValueStatus_Severity[DataValue_ValueStatus_Severity["UNDEFINED_ALARM"] = 4] = "UNDEFINED_ALARM";
})(DataValue_ValueStatus_Severity || (DataValue_ValueStatus_Severity = {}));
/**
 *
 * Image file format.  Also used as file extension.
 *
 * @generated from protobuf enum Image.FileType
 */
export var Image_FileType;
(function (Image_FileType) {
    /**
     * @generated from protobuf enum value: RAW = 0;
     */
    Image_FileType[Image_FileType["RAW"] = 0] = "RAW";
    /**
     * @generated from protobuf enum value: JPEG = 1;
     */
    Image_FileType[Image_FileType["JPEG"] = 1] = "JPEG";
    /**
     * @generated from protobuf enum value: GIF = 2;
     */
    Image_FileType[Image_FileType["GIF"] = 2] = "GIF";
    /**
     * @generated from protobuf enum value: TIFF = 3;
     */
    Image_FileType[Image_FileType["TIFF"] = 3] = "TIFF";
    /**
     * @generated from protobuf enum value: BMP = 4;
     */
    Image_FileType[Image_FileType["BMP"] = 4] = "BMP";
    /**
     * @generated from protobuf enum value: PNG = 5;
     */
    Image_FileType[Image_FileType["PNG"] = 5] = "PNG";
    /**
     * @generated from protobuf enum value: EPS = 6;
     */
    Image_FileType[Image_FileType["EPS"] = 6] = "EPS";
    /**
     * @generated from protobuf enum value: SVG = 7;
     */
    Image_FileType[Image_FileType["SVG"] = 7] = "SVG";
    /**
     * @generated from protobuf enum value: PDF = 8;
     */
    Image_FileType[Image_FileType["PDF"] = 8] = "PDF";
})(Image_FileType || (Image_FileType = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Attribute$Type extends MessageType {
    constructor() {
        super("Attribute", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Attribute
 */
export const Attribute = new Attribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventMetadata$Type extends MessageType {
    constructor() {
        super("EventMetadata", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "startTimestamp", kind: "message", T: () => Timestamp },
            { no: 3, name: "stopTimestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* Timestamp startTimestamp */ 2:
                    message.startTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTimestamp);
                    break;
                case /* Timestamp stopTimestamp */ 3:
                    message.stopTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.stopTimestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* Timestamp startTimestamp = 2; */
        if (message.startTimestamp)
            Timestamp.internalBinaryWrite(message.startTimestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Timestamp stopTimestamp = 3; */
        if (message.stopTimestamp)
            Timestamp.internalBinaryWrite(message.stopTimestamp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EventMetadata
 */
export const EventMetadata = new EventMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Timestamp$Type extends MessageType {
    constructor() {
        super("Timestamp", [
            { no: 1, name: "epochSeconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "nanoseconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.epochSeconds = 0n;
        message.nanoseconds = 0n;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 epochSeconds */ 1:
                    message.epochSeconds = reader.uint64().toBigInt();
                    break;
                case /* uint64 nanoseconds */ 2:
                    message.nanoseconds = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 epochSeconds = 1; */
        if (message.epochSeconds !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.epochSeconds);
        /* uint64 nanoseconds = 2; */
        if (message.nanoseconds !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.nanoseconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Timestamp
 */
export const Timestamp = new Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimestampList$Type extends MessageType {
    constructor() {
        super("TimestampList", [
            { no: 1, name: "timestamps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Timestamp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.timestamps = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Timestamp timestamps */ 1:
                    message.timestamps.push(Timestamp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated Timestamp timestamps = 1; */
        for (let i = 0; i < message.timestamps.length; i++)
            Timestamp.internalBinaryWrite(message.timestamps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TimestampList
 */
export const TimestampList = new TimestampList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SamplingClock$Type extends MessageType {
    constructor() {
        super("SamplingClock", [
            { no: 1, name: "startTime", kind: "message", T: () => Timestamp },
            { no: 2, name: "periodNanos", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.periodNanos = 0n;
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Timestamp startTime */ 1:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* uint64 periodNanos */ 2:
                    message.periodNanos = reader.uint64().toBigInt();
                    break;
                case /* uint32 count */ 3:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* Timestamp startTime = 1; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 periodNanos = 2; */
        if (message.periodNanos !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.periodNanos);
        /* uint32 count = 3; */
        if (message.count !== 0)
            writer.tag(3, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SamplingClock
 */
export const SamplingClock = new SamplingClock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataTimestamps$Type extends MessageType {
    constructor() {
        super("DataTimestamps", [
            { no: 1, name: "samplingClock", kind: "message", oneof: "value", T: () => SamplingClock },
            { no: 2, name: "timestampList", kind: "message", oneof: "value", T: () => TimestampList }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SamplingClock samplingClock */ 1:
                    message.value = {
                        oneofKind: "samplingClock",
                        samplingClock: SamplingClock.internalBinaryRead(reader, reader.uint32(), options, message.value.samplingClock)
                    };
                    break;
                case /* TimestampList timestampList */ 2:
                    message.value = {
                        oneofKind: "timestampList",
                        timestampList: TimestampList.internalBinaryRead(reader, reader.uint32(), options, message.value.timestampList)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* SamplingClock samplingClock = 1; */
        if (message.value.oneofKind === "samplingClock")
            SamplingClock.internalBinaryWrite(message.value.samplingClock, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* TimestampList timestampList = 2; */
        if (message.value.oneofKind === "timestampList")
            TimestampList.internalBinaryWrite(message.value.timestampList, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataTimestamps
 */
export const DataTimestamps = new DataTimestamps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExceptionalResult$Type extends MessageType {
    constructor() {
        super("ExceptionalResult", [
            { no: 1, name: "exceptionalResultStatus", kind: "enum", T: () => ["ExceptionalResult.ExceptionalResultStatus", ExceptionalResult_ExceptionalResultStatus] },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.exceptionalResultStatus = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ExceptionalResult.ExceptionalResultStatus exceptionalResultStatus */ 1:
                    message.exceptionalResultStatus = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* ExceptionalResult.ExceptionalResultStatus exceptionalResultStatus = 1; */
        if (message.exceptionalResultStatus !== 0)
            writer.tag(1, WireType.Varint).int32(message.exceptionalResultStatus);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExceptionalResult
 */
export const ExceptionalResult = new ExceptionalResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataColumn$Type extends MessageType {
    constructor() {
        super("DataColumn", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dataValues", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataValue }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.dataValues = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated DataValue dataValues */ 2:
                    message.dataValues.push(DataValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated DataValue dataValues = 2; */
        for (let i = 0; i < message.dataValues.length; i++)
            DataValue.internalBinaryWrite(message.dataValues[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataColumn
 */
export const DataColumn = new DataColumn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataValue$Type extends MessageType {
    constructor() {
        super("DataValue", [
            { no: 1, name: "stringValue", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "booleanValue", kind: "scalar", oneof: "value", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "uintValue", kind: "scalar", oneof: "value", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "ulongValue", kind: "scalar", oneof: "value", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "intValue", kind: "scalar", oneof: "value", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "longValue", kind: "scalar", oneof: "value", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "floatValue", kind: "scalar", oneof: "value", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "doubleValue", kind: "scalar", oneof: "value", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "byteArrayValue", kind: "scalar", oneof: "value", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "arrayValue", kind: "message", oneof: "value", T: () => Array$ },
            { no: 11, name: "structureValue", kind: "message", oneof: "value", T: () => Structure },
            { no: 12, name: "imageValue", kind: "message", oneof: "value", T: () => Image },
            { no: 13, name: "timestampValue", kind: "message", oneof: "value", T: () => Timestamp },
            { no: 15, name: "valueStatus", kind: "message", T: () => DataValue_ValueStatus }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stringValue */ 1:
                    message.value = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* bool booleanValue */ 2:
                    message.value = {
                        oneofKind: "booleanValue",
                        booleanValue: reader.bool()
                    };
                    break;
                case /* uint32 uintValue */ 3:
                    message.value = {
                        oneofKind: "uintValue",
                        uintValue: reader.uint32()
                    };
                    break;
                case /* uint64 ulongValue */ 4:
                    message.value = {
                        oneofKind: "ulongValue",
                        ulongValue: reader.uint64().toBigInt()
                    };
                    break;
                case /* sint32 intValue */ 5:
                    message.value = {
                        oneofKind: "intValue",
                        intValue: reader.sint32()
                    };
                    break;
                case /* sint64 longValue */ 6:
                    message.value = {
                        oneofKind: "longValue",
                        longValue: reader.sint64().toBigInt()
                    };
                    break;
                case /* float floatValue */ 7:
                    message.value = {
                        oneofKind: "floatValue",
                        floatValue: reader.float()
                    };
                    break;
                case /* double doubleValue */ 8:
                    message.value = {
                        oneofKind: "doubleValue",
                        doubleValue: reader.double()
                    };
                    break;
                case /* bytes byteArrayValue */ 9:
                    message.value = {
                        oneofKind: "byteArrayValue",
                        byteArrayValue: reader.bytes()
                    };
                    break;
                case /* Array arrayValue */ 10:
                    message.value = {
                        oneofKind: "arrayValue",
                        arrayValue: Array$.internalBinaryRead(reader, reader.uint32(), options, message.value.arrayValue)
                    };
                    break;
                case /* Structure structureValue */ 11:
                    message.value = {
                        oneofKind: "structureValue",
                        structureValue: Structure.internalBinaryRead(reader, reader.uint32(), options, message.value.structureValue)
                    };
                    break;
                case /* Image imageValue */ 12:
                    message.value = {
                        oneofKind: "imageValue",
                        imageValue: Image.internalBinaryRead(reader, reader.uint32(), options, message.value.imageValue)
                    };
                    break;
                case /* Timestamp timestampValue */ 13:
                    message.value = {
                        oneofKind: "timestampValue",
                        timestampValue: Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.value.timestampValue)
                    };
                    break;
                case /* DataValue.ValueStatus valueStatus */ 15:
                    message.valueStatus = DataValue_ValueStatus.internalBinaryRead(reader, reader.uint32(), options, message.valueStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string stringValue = 1; */
        if (message.value.oneofKind === "stringValue")
            writer.tag(1, WireType.LengthDelimited).string(message.value.stringValue);
        /* bool booleanValue = 2; */
        if (message.value.oneofKind === "booleanValue")
            writer.tag(2, WireType.Varint).bool(message.value.booleanValue);
        /* uint32 uintValue = 3; */
        if (message.value.oneofKind === "uintValue")
            writer.tag(3, WireType.Varint).uint32(message.value.uintValue);
        /* uint64 ulongValue = 4; */
        if (message.value.oneofKind === "ulongValue")
            writer.tag(4, WireType.Varint).uint64(message.value.ulongValue);
        /* sint32 intValue = 5; */
        if (message.value.oneofKind === "intValue")
            writer.tag(5, WireType.Varint).sint32(message.value.intValue);
        /* sint64 longValue = 6; */
        if (message.value.oneofKind === "longValue")
            writer.tag(6, WireType.Varint).sint64(message.value.longValue);
        /* float floatValue = 7; */
        if (message.value.oneofKind === "floatValue")
            writer.tag(7, WireType.Bit32).float(message.value.floatValue);
        /* double doubleValue = 8; */
        if (message.value.oneofKind === "doubleValue")
            writer.tag(8, WireType.Bit64).double(message.value.doubleValue);
        /* bytes byteArrayValue = 9; */
        if (message.value.oneofKind === "byteArrayValue")
            writer.tag(9, WireType.LengthDelimited).bytes(message.value.byteArrayValue);
        /* Array arrayValue = 10; */
        if (message.value.oneofKind === "arrayValue")
            Array$.internalBinaryWrite(message.value.arrayValue, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* Structure structureValue = 11; */
        if (message.value.oneofKind === "structureValue")
            Structure.internalBinaryWrite(message.value.structureValue, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* Image imageValue = 12; */
        if (message.value.oneofKind === "imageValue")
            Image.internalBinaryWrite(message.value.imageValue, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* Timestamp timestampValue = 13; */
        if (message.value.oneofKind === "timestampValue")
            Timestamp.internalBinaryWrite(message.value.timestampValue, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* DataValue.ValueStatus valueStatus = 15; */
        if (message.valueStatus)
            DataValue_ValueStatus.internalBinaryWrite(message.valueStatus, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataValue
 */
export const DataValue = new DataValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataValue_ValueStatus$Type extends MessageType {
    constructor() {
        super("DataValue.ValueStatus", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "statusCode", kind: "enum", T: () => ["DataValue.ValueStatus.StatusCode", DataValue_ValueStatus_StatusCode] },
            { no: 3, name: "severity", kind: "enum", T: () => ["DataValue.ValueStatus.Severity", DataValue_ValueStatus_Severity] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.message = "";
        message.statusCode = 0;
        message.severity = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* DataValue.ValueStatus.StatusCode statusCode */ 2:
                    message.statusCode = reader.int32();
                    break;
                case /* DataValue.ValueStatus.Severity severity */ 3:
                    message.severity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* DataValue.ValueStatus.StatusCode statusCode = 2; */
        if (message.statusCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.statusCode);
        /* DataValue.ValueStatus.Severity severity = 3; */
        if (message.severity !== 0)
            writer.tag(3, WireType.Varint).int32(message.severity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataValue.ValueStatus
 */
export const DataValue_ValueStatus = new DataValue_ValueStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Structure$Type extends MessageType {
    constructor() {
        super("Structure", [
            { no: 1, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Structure_Field }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.fields = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Structure.Field fields */ 1:
                    message.fields.push(Structure_Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated Structure.Field fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            Structure_Field.internalBinaryWrite(message.fields[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Structure
 */
export const Structure = new Structure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Structure_Field$Type extends MessageType {
    constructor() {
        super("Structure.Field", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => DataValue }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* DataValue value */ 2:
                    message.value = DataValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* DataValue value = 2; */
        if (message.value)
            DataValue.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Structure.Field
 */
export const Structure_Field = new Structure_Field$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Array$$Type extends MessageType {
    constructor() {
        super("Array", [
            { no: 1, name: "dataValues", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataValue }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.dataValues = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DataValue dataValues */ 1:
                    message.dataValues.push(DataValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated DataValue dataValues = 1; */
        for (let i = 0; i < message.dataValues.length; i++)
            DataValue.internalBinaryWrite(message.dataValues[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Array
 */
export const Array$ = new Array$$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Image$Type extends MessageType {
    constructor() {
        super("Image", [
            { no: 1, name: "image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "fileType", kind: "enum", T: () => ["Image.FileType", Image_FileType] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.image = new Uint8Array(0);
        message.fileType = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes image */ 1:
                    message.image = reader.bytes();
                    break;
                case /* Image.FileType fileType */ 2:
                    message.fileType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes image = 1; */
        if (message.image.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.image);
        /* Image.FileType fileType = 2; */
        if (message.fileType !== 0)
            writer.tag(2, WireType.Varint).int32(message.fileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Image
 */
export const Image = new Image$Type();
